数据类型

注意：==>
对于值之间的比较有非常严格的限制，只有两个相同类型的值才可以进行比较，如果值的类型是接口（interface），那么它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值可以不是常量，但是类型必须和该常量类型相同。如果以上条件都不满足，则必须将其中一个值的类型转换为和另外一个值的类型相同之后才可以进行比较。

整型:
	int和uint：对应特定CPU平台的字长

浮点类型:
	max.MAXFloat32:表示float32能取到的最大数值，大约是3.4e38
	max.MAXFloat64:表示float64能取到的最大数值，大约是1.8e308
	float32和float64能表示的最小值分别为1.4e-45和4.9e-324

	一个 float32 类型的浮点数可以提供大约 6 个十进制数的精度，而 float64 则可以提供约 15 个十进制数的精度，
	通常应该优先使用 float64 类型，因为 float32 类型的累计计算误差很容易扩散，并且 float32 能精确表示的正整数并不是很大。 

	var f float32 = 16777216 // 1 << 24 // float32中有效位23位，已经溢出
	fmt.Println(f == f+1)    // "true"!

	输出:
	fmt.Printf("%f\n", math.Pi) => 3.141593
    	fmt.Printf("%.2f\n", math.Pi) =>3.14

复数:
	complex128为复数的默认类型
	声明：var name complex128 = complex(x,y) 或者 name := complex(x,y)
	取实数部分：real(x)
	取序数部分：imag(x)
	复数也可以用==和!=进行相等比较，只有两个复数的实部和虚部都相等的时候它们才是相等的。

布尔类型:
	值只有两种：true 或 false。
	一元操作符!对应逻辑非操作，因此!true的值为 false，更复杂一些的写法是(!true==false) ==true，
	实际开发中我们应尽量采用比较简洁的布尔表达式，就像用 x 来表示x==true。

	布尔型无法参与数值运算，也无法与其他类型进行转换。
	不允许将整型强制转换为布尔型
	布尔值并不会隐式转换为数字值 0 或 1，反之亦然。
	如果需要经常做类似的转换，可以将转换的代码封装成一个函数
	
	// bool转整数
	func btoi(b bool)int{
		if b{
			return 1
		}else{
			return 0
		}
	}
	// 整数转bool
	func itob(i int)bool{ return i != 0 } 

字符串:
	一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，但是通常是用来包含可读的文本，
	字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码表上的字符时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。

	字符串是一种值类型，且值不可变，即创建某个文本后将无法再次修改这个文本的内容，
	更深入地讲，字符串是字节的定长数组。

	一般的比较运算符（==、!=、<、<=、>=、>）是通过在内存中按字节比较来实现字符串比较的，因此比较的结果是字符串自然编码的顺序。
	字符串所占的字节长度可以通过函数 len() 来获取，例如 len(str)。

	字符串的内容（纯字节）可以通过标准索引法来获取，在方括号[ ]内写入索引，索引从 0 开始计数：
    		字符串 str 的第 1 个字节：str[0]
    		第 i 个字节：str[i - 1]
    		最后 1 个字节：str[len(str)-1]
		需要注意的是，这种转换方案只对纯 ASCII 码的字符串有效。

    	注意：获取字符串中某个字节的地址属于非法行为，例如 &str[i]。

	字符串拼接： + 或者 +=

	字符串实现基于UTF-8编码:
		内部实现使用 UTF-8 编码，通过 rune 类型，可以方便地对每个 UTF-8 字符进行访问。
		当然，Go语言也支持按照传统的 ASCII 码方式逐字符进行访问。
	使用双引号书写字符串的方式是字符串常见表达方式之一，被称为字符串字面量（string literal）

	多行：`` => tab键上方符号

	获取字符串长度：
    		ASCII 字符串长度使用 len() 函数。 => 字节数
    		Unicode 字符串长度使用 utf8.RuneCountInString() 函数。 => utf字符个数


字符类型:	
    	1)一种是 uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符。
    	2)另一种是 rune 类型，代表一个 UTF-8 字符
	当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。rune 类型等价于 int32 类型。

	写法:
	ascii码表：
		var ch byte = 65 	=> 10进制
		var ch byte = 'A' 	=>
		var ch byte = '\x41' 	=> 16进制
		var ch byte = \377 	=> 8进制
	unicode字符：
		var ch int = '\u0041' 		=> 4字节使用\u
		var ch2 int = '\u03B2'
		var ch3 int = '\U00101234'	=> 8字节使用\U
		fmt.Printf("%d - %d - %d\n", ch, ch2, ch3) // integer
		fmt.Printf("%c - %c - %c\n", ch, ch2, ch3) // character
		fmt.Printf("%X - %X - %X\n", ch, ch2, ch3) // UTF-8 bytes
		fmt.Printf("%U - %U - %U", ch, ch2, ch3)   // UTF-8 code point
	输出：
		65 - 946 - 1053236
		A - β - r
		41 - 3B2 - 101234
		U+0041 - U+03B2 - U+101234
	unicode包:
    		判断是否为字母：unicode.IsLetter(ch)
    		判断是否为数字：unicode.IsDigit(ch)
    		判断是否为空白符号：unicode.IsSpace(ch)

数据类型转换：
	valueOfTypeB = typeB(valueOfTypeA)
	只有相同底层类型的变量之间可以进行相互转换（如将 int16 类型转换成 int32 类型），
	不同底层类型的变量相互转换时会引发编译错误（如将 bool 类型转换为 int 类型）：

	浮点数在转换为整型时，会将小数部分去掉，只保留整数部分。

指针类型:
    	类型指针，允许对这个指针类型的数据进行修改，传递数据可以直接使用指针，而无须拷贝数据，
	类型指针不能进行偏移和运算。
    	切片，由指向起始元素的原始指针、元素数量和容量组成。

	不会发生指针偏移，从而避免了非法修改关键性数据的问题。
	同时，垃圾回收也比较容易对不会发生偏移的指针进行检索和回收。
	
	一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 32 和 64 位机器上分别占用 4 或 8 个字节，
	占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 nil。
	指针变量通常缩写为 ptr。

	ptr := &v    // v 的类型为 T
	其中 v 代表被取地址的变量，变量 v 的地址使用变量 ptr 进行接收，ptr 的类型为*T，称做 T 的指针类型，*代表指针

	提示：变量、指针和地址三者的关系是，每个变量都拥有地址，指针的值就是地址。 

	变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：
	    	对变量进行取地址操作使用&操作符，可以获得这个变量的指针变量。
	    	指针变量的值是指针地址。
	    	对指针变量进行取值操作使用*操作符，可以获得指针变量指向的原变量的值。

	创建指针的另一种方式：new()函数
		new(类型)
	new() 函数可以创建一个对应类型的指针，创建过程会分配内存，被创建的指针指向默认值。


常量：
	布尔型，数字型（整数，浮点，复数）和字符型
	由于编译时的限制，定义常量的表达式必须为能被编译器求值的常量表达式。

	声明语法类似：const name [type] = value

	常量生成器：iota => 区别itoa ***
	生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式
	==>注意理解********相似规则*********

	无类型常量:
	编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有 256bit 的运算精度。
	无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。

	通过延迟明确常量的具体类型，不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。





