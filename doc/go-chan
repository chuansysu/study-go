goroutine之间通信的管道 -- channel

一个 channels 是一个通信机制，它可以让一个 goroutine 通过它给另一个 goroutine 发送值信息。
每个 channel 都有一个特殊的类型，也就是 channels 可发送数据的类型。

声明：
	var 通道变量 chan 通道类型
		
	*****************************************************
	chan 类型的空值是 nil，声明后需要配合 make 后才能使用。
	*****************************************************
		
创建通道：
	通道实例 := make(chan 数据类型)
	
	ch1 := make(chan int)				// 无缓冲通道
	ch2 := make(chan interface{},10) 	// 带缓冲通道
	
	***********************************************
	带缓冲通道被填满时，尝试再次发送数据时发生阻塞。
	带缓冲通道为空时，尝试接收数据时发生阻塞。
	***********************************************
	
	type Equip struct{
	}
	ch3 := make(chan *Equip)
	
	单向通道：一般只在函数形参中出现，单独定义单向通道无意义
	out chan<- int 	// 只写通道，箭头在右边
	in <-chan int	// 只读通道，箭头在左边
	
使用通道发送数据：
	通道变量 <- 值 // ch1 <-10 向通道发送数据10
	
	值：可以是变量、常量、表达式或者函数返回值等。
	值的类型必须与ch通道的元素类型一致。
	无缓冲通道上的发送操作将会阻塞，直到另一个goroutine在对应的通道上执行接收操作，这时值传送完成，两个goroutine都可以继续执行。
	
使用通道接收数据：
	接收值的变量 <-channel // x := <-ch1 从通道接收数据10
	
	① 通道的收发操作在不同的两个 goroutine 间进行。
	由于通道的数据在没有接收方处理时，数据发送方会持续阻塞，因此通道的接收必定在另外一个 goroutine 中进行。

	② 接收将持续阻塞直到发送方发送数据。
	如果接收方接收时，通道中没有发送方发送数据，接收方也会发生阻塞，直到发送方发送数据为止。

	③ 每次接收一个元素。
	通道一次只能接收一个数据元素。
	
	4种接收方式：
		1.阻塞接收
			data := <-ch
			执行该语句时将会阻塞，直到接收到数据并赋值给 data 变量。
			
		2.非阻塞接收
			data,ok := <-ch
			data：表示接收到的数据。未接收到数据时，data 为通道类型的零值。
			ok：表示是否接收到数据。

			非阻塞的通道接收方法可能造成高的 CPU 占用，因此使用非常少。
			如果需要实现接收超时检测，可以配合 select 和计时器 channel 进行
			
		3.接收任意数据，忽略接收的数据
			<-ch
			执行该语句时将会发生阻塞，直到接收到数据，但接收到的数据会被忽略。
			这个方式实际上只是通过通道在 goroutine 间阻塞收发实现并发同步。
		
		4.循环接收
			for data := range ch{
			}
			通道 ch 是可以进行遍历的，遍历的结果就是接收到的数据。
			数据类型就是通道的数据类型。
			通过 for 遍历获得的变量只有一个，即上面例子中的 data。
			
关闭channel:
	close(ch)
	
	如何知道已经关闭？
	x,ok := <-ch
	ok == false  ==>已经关闭
	
为什么Go语言对通道要限制长度而不提供无限长度的通道？

	我们知道通道（channel）是在两个 goroutine 间通信的桥梁。
	使用 goroutine 的代码必然有一方提供数据，一方消费数据。
	当提供数据一方的数据供给速度大于消费方的数据处理速度时，
	如果通道不限制长度，那么内存将不断膨胀直到应用崩溃。
	因此，限制通道的长度有利于约束数据提供方的供给速度，
	供给数据量必须在消费方处理量+通道长度的范围内，才能正常地处理数据。
	
channel超时机制：
	select
	 select 机制不是专门为超时而设计的，却能很方便的解决超时问题，
	 因为 select 的特点是只要其中有一个 case 已经完成，程序就会继续往下执行，
	 而不会考虑其他 case 的情况。
	
	select {
		case <-chan1:
		// 如果chan1成功读到数据，则进行该case处理语句
		case chan2 <- 1:
		// 如果成功向chan2写入数据，则进行该case处理语句
		default:
		// 如果上面都没有成功，则进入default处理流程
	}
	
	// default:非必需
	在一个 select 语句中，Go语言会按顺序从头至尾评估每一个发送和接收的语句。
	如果其中的任意一语句可以继续执行（即没有被阻塞），那么就从那些可以执行的语句中任意选择一条来使用。

	如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有如下两种可能的情况：
		如果给出了 default 语句，那么就会执行 default 语句，同时程序的执行会从 select 语句后的语句中恢复；
		如果没有 default 语句，那么 select 语句将被阻塞，直到至少有一个通信可以进行下去。
