切片（slice）
	是对数组的一个连续片段的引用，所以切片是一个引用类型
	这个片段可以是整个数组，也可以是由起始和终止索引标识的一些项的子集，
	需要注意的是，终止索引标识的项不包括在切片内。

	切片的内部结构包含地址、大小和容量，切片一般用于快速地操作一块数据集合，
	如果将数据集合比作切糕的话，切片就是你要的“那一块”，
	切的过程包含从哪里开始（切片的起始位置）及切多大（切片的大小），容量可以理解为装切片的口袋大小

	切片 => 地址(开始位置)+大小+容量

从数组或切片生成新的切片
	切片默认指向一段连续内存区域，可以是数组，也可以是切片本身。
	slice [开始位置 : 结束位置]
		slice：表示目标切片对象；
		开始位置：对应目标切片对象的索引；
		结束位置：对应目标切片的结束索引。

	取出的元素数量为：结束位置 - 开始位置；
	取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取；
	当缺省开始位置时，表示从连续区域开头到结束位置；
	当缺省结束位置时，表示从开始位置到整个连续区域末尾；
	两者同时缺省时，与切片本身等效；
	两者同时为 0 时，等效于空切片，一般用于切片复位。

根据索引位置取切片 slice 元素值时，取值范围是（0～len(slice)-1），超界会报运行时错误，生成切片时，结束位置可以填写 len(slice) 但不会报错。

a := []int{1,2,3}
表示原有切片：a[:]
重置切片：a[0:0]

直接声明新的切片:
	var name []Type

	var strList []string
	var numList []int
	var numListEmpty = []int{}
	fmt.Println(strList == nil) 		=>true
	fmt.Println(numList == nil)		=>true
	fmt.Println(numListEmpty == nil)	=>false,因为已经分配内存len(numListEmpty)=>0

***判断一个切片是否为空：len(slice)==0 =>不使用slice == nil因为切片不等于nil情况下切片也可能为空***(见上面代码)

切片是动态结构，只能与 nil 判定相等，不能互相判定相等。声明新的切片后，可以使用 append() 函数向切片中添加元素。

使用 make() 函数构造切片:
	make( []Type, size, cap )
	Type 是指切片的元素类型，size 指的是为这个类型分配多少个元素，
	cap 为预分配的元素数量，这个值设定后不影响 size，只是能提前分配空间，降低多次分配空间造成的性能问题。
	**********cap >= size**********
	当cap < size => invalid argument: length and capacity swapped

温馨提示:
使用 make() 函数生成的切片一定发生了内存分配操作，但给定开始与结束位置（包括切片复位）的切片只是将新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作。

待深入研究：********************************切片增长规则********************************(见最后)

append()为切片增加元素：
	尾部增加: 
		var a []int
		a = append(a,1)	=> append返回一个新的临时切片，需要重新赋值给a，a才会改变
		a = append(a,[]int{1,2,3}...)  =>// 追加一个切片, 切片需要解包，...表示添加切片所有元素
	使用 append() 函数为切片动态添加元素时，如果空间不足以容纳足够多的元素，切片就会进行*****扩容*****，此时新切片的长度会发生改变。

	头部增加:
		var a = []int{1,2,3}
		a = append([]int{0},a...)
		a = append([]int{-3,-2,-1},a...)

	append 函数返回新切片的特性，所以切片也支持链式操作，我们可以将多个 append 操作组合起来，实现在切片中间插入元素：
		var a []int
		a = append(a[:i], append([]int{x}, a[i:]...)...) // 在第i个位置插入x
		a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片

copy():切片复制
	copy( destSlice, srcSlice []T) int
	将一个数组切片复制到另一个数组切片中，来源和目标的***类型必须一致***，copy() 函数的返回值表示实际发生复制的元素个数
	如果加入的两个数组切片不一样大，就会按照其中***较小***的那个数组切片的元素个数进行复制。

从切片中删除元素:
	Go语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素
	从开头位置删除、从中间位置删除和从尾部删除，其中删除切片尾部的元素速度最快。

	删除切片元素的***本质***是，以被删除元素为分界点，将前后两个部分的内存重新连接起来。 

	从开头位置删除:
		1)直接移动数据指针: => 快速
			a = []int{1, 2, 3}
			a = a[1:] // 删除开头1个元素
			a = a[N:] // 删除开头N个元素
		2)不移动数据指针： =>慢
			将后面的数据向开头移动，可以用 append 原地完成
			（所谓原地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化）： 
			a = []int{1, 2, 3}
			a = append(a[:0], a[1:]...) // 删除开头1个元素
			a = append(a[:0], a[N:]...) // 删除开头N个元素
		3)使用copy()来删除:
			a = []int{1, 2, 3}
			a = a[:copy(a, a[1:])] // 删除开头1个元素 =>len(a)=2,cap(a)=3
			a = a[:copy(a, a[N:])] // 删除开头N个元素
	从中间位置删除:
		需要对剩余的元素进行一次整体挪动
			a = []int{1, 2, 3, ...}
			a = append(a[:i], a[i+1:]...) // 删除中间1个元素
			a = append(a[:i], a[i+N:]...) // 删除中间N个元素
			a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素
			a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素
	从尾部删除:
			a = []int{1, 2, 3}
			a = a[:len(a)-1] // 删除尾部1个元素
			a = a[:len(a)-N] // 删除尾部N个元素

	删除开头的元素和删除尾部的元素都可以认为是删除中间元素操作的特殊情况

提示:
连续容器的元素删除无论在任何语言中，都要将删除点前后的元素移动到新的位置，随着元素的增加，这个过程将会变得极为耗时，因此，当业务需要大量、频繁地从一个切片中删除元素时，如果对性能要求较高的话，就需要考虑更换其他的容器了（如双链表等能快速从删除点删除元素）。

切片迭代循环： for range
	需要强调的是，range 返回的是每个元素的***副本***，而不是直接返回对该元素的引用
	关键字 range 总是会从切片头部开始迭代
	如果想对迭代做更多的控制，则可以使用传统的 for 循环

	// 创建一个整型切片，并赋值
	slice := []int{10, 20, 30, 40}
	// 迭代每个元素，并显示值和地址
	for index, value := range slice {
    		fmt.Printf("Value: %d Value-Addr: %X ElemAddr: %X\n", value, &value, &slice[index])
	}

	Value: 10 Value-Addr: 10500168 ElemAddr: 1052E100
	Value: 20 Value-Addr: 10500168 ElemAddr: 1052E104
	Value: 30 Value-Addr: 10500168 ElemAddr: 1052E108
	Value: 40 Value-Addr: 10500168 ElemAddr: 1052E10C
	迭代返回的变量是一个在迭代过程中根据切片依次赋值的新变量，所以 value 的地址总是相同的***返回副本赋值***，
	要想获取每个元素的地址，需要使用切片变量和索引值（例如上面代码中的 &slice[index]）。

for ... range可遍历对象:
	切片，数组，字符串，map，通道channel

多维切片:
	var sliceName [][]...[]sliceType
	// 声明一个二维整型切片并赋值
	slice := [][]int{{10}, {100, 200}}
	==>一个包含两个元素的外层切片，同时每个元素包又含一个内层的整型切片
	slice = append(slice,[]int{1000,2000}) =>[[10],[100,200],[1000,2000]]
	
切片扩容规则：

//go1.15.6 源码 src/runtime/slice.go
func growslice(et *_type, old slice, cap int) slice {
	//省略部分判断代码
	//计算扩容部分，其中，cap : 所需容量，newcap : 最终申请容量
	newcap := old.cap
	doublecap := newcap + newcap
	if cap > doublecap {
		newcap = cap
	} else {
		if old.len < 1024 {
		newcap = doublecap
		} else {
   			// Check 0 < newcap to detect overflow
   			// and prevent an infinite loop.
   			for 0 < newcap && newcap < cap {
    				newcap += newcap / 4
   			}
   			// Set newcap to the requested cap when
   			// the newcap calculation overflowed.
   			if newcap <= 0 {
    				newcap = cap
   			}
  		}
 	} 
 	//省略部分判断代码
}

1. 如果当前所需容量大于原先容量的两倍，则最终申请容量为当前所需容量。(***最新版数据类型不同作不同处理还有内存对齐***)
2.如果<条件1>不满足，表示当前所需容量不大于原容量的两倍，则进行如下判断：
3.如果原切片长度小于1024(***最新版是256***)，则最终申请容量等于原容量的两倍。
4.否则，最终申请容量每次增加1/4(***最新版newcap += (newcap + 3*256) / 4***)，直到大于所需容量为止，然后判断最终容量是否溢出，如果溢出，最终申请容量等于所需容量。




