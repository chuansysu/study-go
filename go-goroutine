在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine。 

格式：
	go 函数名(参数列表)
	使用 go 关键字创建 goroutine 时，被调用函数的返回值会被忽略。

	***********************************************
	所有 goroutine 在 main() 函数结束时会一同结束。
	***********************************************

	暂时没有标准接口获取 goroutine 的 ID。

	runtime.GOMAXPROCS(逻辑CPU数量)
	<1：不修改任何数值。
	=1：单核心执行。
	>1：多核并发执行。
	runtime.GOMAXPROCS(runtime.NumCPU())
		=>NumCPU()：获取CPU数量


	并发（concurrency）：
		把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。
	并行（parallelism）：
		把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。

	******************************************************
	goroutine 可能发生并行执行；但 coroutine 始终顺序执行。
	******************************************************

	goroutine 属于抢占式任务处理，应用程序对 CPU 的控制最终还需要由操作系统来管理，
	操作系统如果发现一个应用程序长时间大量地占用 CPU，那么用户有权终止这个任务。

	线程有固定的栈，基本都是2 MB，都是固定分配的；这个栈用于保存局部变量，在函数切换时使用。
	但是对于goroutine来说，一个大小固定的栈可能会导致资源浪费，所以Go采用了动态扩张收缩的策略，初始化为2KB，最大可扩张到1GB。
								
	*********************************************************************************************************************************
	Go语言的协程是抢占式调度的，当遇到长时间执行或者进行系统调用时，会主动把当前goroutine的CPU §转让出去，让其他goroutine能被调度并执行。
	*********************************************************************************************************************************

GPM模型：
	G（Goroutine）: 即Go协程，每个go关键字都会创建一个协程。
	M（Machine）： 工作线程，在Go中称为Machine。
	P(Processor): go中管理协程的数据结构
	M必须拥有P才可以执行G中的代码，P含有一个包含多个G的队列，P可以调度G交由M执行。

	P的个数在程序启动时决定，默认情况下等同于CPU的核数，由于M必须持有一个P才可以运行Go代码，
	所以同时运行的M个数，也即线程数一般等同于CPU的个数，以达到尽可能的使用CPU而又不至于产生过多的线程切换开销。

Goroutine调度策略：
	队列轮转：
		每个P维护着一个包含G的队列，不考虑G进入系统调用或IO操作的情况下，P周期性的将G调度到M中执行，执行一小段时间，将上下文保存下来，
		然后将G放到队列尾部，然后从队列中重新取出一个G进行调度。

		除了每个P维护的G队列以外，还有一个全局的队列，每个P会周期性地查看全局队列中是否有G待运行并将其调度到M中执行，全局队列中G的来源，
		主要有从系统调用中恢复的G。之所以P会周期性地查看全局队列，也是为了防止全局队列中的G被饿死。

	系统调用：
		一般情况下M的个数会略大于P的个数，这多出来的M将会在G产生系统调用时发挥作用。
		类似线程池，Go也提供一个M的池子，需要时从池子中获取，用完放回池子，不够用时就再创建一个。

		如图所示，当G0即将进入系统调用时，M0将释放P，进而某个空闲的M1获取P，继续执行P队列中剩下的G。
		而M0由于陷入系统调用而进被阻塞，M1接替M0的工作，只要P不空闲，就可以保证充分利用CPU。
		常见的像文件io操作会调用系统调用，进入阻塞状态。

		M1的来源有可能是M的缓存池，也可能是新建的。当G0系统调用结束后，根据M0是否能获取到P，将会将G0做不同的处理：

		如果有空闲的P，则获取一个P，继续执行G0。
		如果没有空闲的P，则将G0放入全局队列，等待被其他的P调度。然后M0将进入缓存池睡眠。

	工作量窃取：
		多个P中维护的G队列有可能是不均衡的
		竖线左侧中右边的P已经将G全部执行完，然后去查询全局队列，全局队列中也没有G，而另一个M中除了正在运行的G外，队列中还有3个G待运行。
		此时，空闲的P会将其他P中的G偷取一部分过来，一般每次偷取一半。偷取完如右图所示。

Tips
一般来讲，程序运行时就将GOMAXPROCS大小设置为CPU核数，可让Go程序充分利用CPU。在某些IO密集型的应用里，这个值可能并不意味着性能最好。理论上当某个Goroutine进入系统调用时，会有一个新的M被启用或创建，继续占满CPU。但由于Go调度器检测到M被阻塞是有一定延迟的，也即旧的M被阻塞和新的M得到运行之间是有一定间隔的，所以在IO密集型应用中不妨把GOMAXPROCS设置的大一些，或许会有好的效果。

原文链接：https://blog.csdn.net/qq_44800780/article/details/123128462


















