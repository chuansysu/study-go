package main

import (
	"encoding/base64"
	"fmt"
)

/*
Base64是一种编码方式，将二进制编码为字符
Base64编码后的字符范围为64个可打印字符
编码后的结果具有不可读性，需要解码：
	即Base64不是加密方法，而是编码方式，
	是从一种语言翻译为另一种语言，当然也可以翻译回去

64个可打印字符:
	26个字母的大小写、10个阿拉伯数字、'+'号 和 '/'号
	（其实还有一个 '=' 号用于后缀）

需要注意的是，
	使用Base64编码后，3个字节会转为4个字节，编码后的需要传输的数据比编码前多了 1/3。
*/

/*
Base64的编码过程:
	1.将原始数据每三个字节分为一组，一共24个比特位
	2.将24个比特位分为4组，每组6个比特位
	3.计算每组的十进制值，根据编码对照表，得到可打印字符串

例子：
	1.给定单词 'Man'，一共三个字节
	2.根据ASCII编码，得到24个比特位
	3.6个一组，分为4组
	4.计算每组的十进制值分别为 19、22、5、46，对照Base64编码表，得到可打印字符串为 'TWFu'

位数不足情况：
	位数不足会有两种情况：两个字节或者一个字节的数据。

	如果是两个字节，也就是16个比特，需要补两个0，
	得到三个Base64编码字符，最后添加一个'='用于补充

	如果是一个字节，也就是8个比特，需要补4个0，
	得到两个Base64编码字符，最后添加两个'='用于补充
*/

/*
解码就是编码的逆向操作：
	1.掉结尾的'='号
	2.根据Base64编码表，找到每个字符对应的编码值
	3.取每个编码值的后6位，形成二进制串
	4.对上述二进制串，每8个构成一个字节，如果最后一组不够8个，一定全是0，丢弃掉
	5.此时得到的就是原始数据的二进制编码，再根据编码方式（例如 ASCII ）等进行解码

例子：
	1.去掉'='，得到 'TWE'
	2.'T':19，'W':22，'E':4
	3.010011 010110 000100
	4.01001101 01100001
	5.M  a
*/

/*
Base64 URL 编码:
	标准Base64编码后会有 '+'号，在HTTP URL传输时，'+'号会被解析成空格，
	这样服务端接收到的数据和传输的数据就不一致。因此衍生出了Base64 URL编码，
	这种编码会把'+'变为'-'，便于在URL中传输。

	为解决此问题，衍生出一种用于URL的改进Base64编码，
	它不仅在末尾去掉填充的'='号，并将标准Base64中的“+”和“/”分别改成了“-”和“_”。
*/

func main() {
	src := "hello world"
	res := base64.StdEncoding.EncodeToString([]byte(src))
	fmt.Println(res)

	s, err := base64.StdEncoding.DecodeString(res)
	fmt.Printf("%T,%v,%v\n", s, s, err)
	fmt.Println(string(s))

	src2 := "信息"
	res2 := base64.URLEncoding.EncodeToString([]byte(src2))
	fmt.Println(res2)

	s2, err := base64.URLEncoding.DecodeString(res2)
	fmt.Println(string(s2), err)
}
